"""
This type stub file was generated by pyright.
"""

import abc
import enum
import functools
from typing import Any, Callable, Dict, List, Optional, Tuple, Union
from lxml import etree
from PIL import Image
from uiautomator2._proto import Direction
from uiautomator2.abstract import AbstractXPathBasedDevice
from uiautomator2.utils import deprecated

logger = ...
class TimeoutException(Exception):
    ...


class XPathError(Exception):
    """basic error for xpath plugin"""
    ...


def safe_xmlstr(s: str) -> str:
    ...

def string_quote(s: str) -> str:
    """quick way to quote string"""
    ...

def str2bytes(v: Union[str, bytes]) -> bytes:
    ...

def is_xpath_syntax_ok(xpath_expression: str) -> bool:
    ...

def convert_to_camel_case(s: str) -> str:
    """
    Convert a string from kebab-case to camelCase.

    Example:
        "hello-world" -> "helloWorld"
    """
    ...

def strict_xpath(xpath: str) -> str:
    """make xpath to be computer recognized xpath"""
    ...

class XPath(str):
    def __new__(cls, value, *args): # -> XPath | Self:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __and__(self, value: XPath) -> XPathSelector:
        ...
    
    def joinpath(self, subpath: str) -> XPath:
        ...
    
    def all(self, source: PageSource): # -> List[XMLElement]:
        ...
    


class PageSource:
    def __init__(self, xml_content: str) -> None:
        ...
    
    @staticmethod
    def parse(data: Union[str, PageSource]) -> PageSource:
        ...
    
    @functools.cached_property
    def root(self) -> etree._Element:
        ...
    
    def find_elements(self, xpath: str) -> List[XMLElement]:
        ...
    


class XPathEntry:
    def __init__(self, d: AbstractXPathBasedDevice) -> None:
        """
        Args:
            d (uiautomator2 instance)
        """
        ...
    
    def global_set(self, key, value): # -> None:
        ...
    
    def implicitly_wait(self, timeout): # -> None:
        """set default timeout when click"""
        ...
    
    @property
    def wait_timeout(self):
        ...
    
    def get_page_source(self) -> PageSource:
        ...
    
    def match(self, xpath, source=...): # -> bool:
        ...
    
    @deprecated(reason="use d.watcher.when(..) instead")
    def when(self, xquery: str):
        ...
    
    @deprecated(reason="use d.watcher.run() instead")
    def run_watchers(self, source=...): # -> None:
        ...
    
    @deprecated(reason="use d.watcher.start(..) instead")
    def watch_background(self, interval: float = ...):
        ...
    
    @deprecated(reason="use d.watcher.stop() instead")
    def watch_stop(self): # -> None:
        """stop watch background"""
        ...
    
    @deprecated(reason="use d.watcher.remove() instead")
    def watch_clear(self): # -> None:
        ...
    
    @deprecated(reason="removed")
    def sleep_watch(self, seconds): # -> None:
        """run watchers when sleep"""
        ...
    
    def click(self, xpath: str, timeout: Optional[float] = ...): # -> None:
        """
        Find element and perform click

        Args:
            xpath (str): xpath string
            timeout (float): pass
            pre_delay (float): pre delay wait time before click

        Raises:
            TimeoutException
        """
        ...
    
    def scroll_to(self, xpath: str, direction: Union[Direction, str] = ..., max_swipes=...) -> Union[XMLElement, None]:
        """
        Need more tests
        scroll up the whole screen until target element founded

        Returns:
            bool (found or not)
        """
        ...
    
    def __call__(self, xpath: str, source: Optional[Union[str, PageSource]] = ...) -> DeviceXPathSelector:
        ...
    


class Operator(str, enum.Enum):
    AND = ...
    OR = ...


class AbstractSelector(abc.ABC):
    @abc.abstractmethod
    def all(self, source: PageSource) -> List[XMLElement]:
        ...
    


class XPathSelector(AbstractSelector):
    def __init__(self, value: Union[str, XPath, AbstractSelector]) -> None:
        ...
    
    def copy(self): # -> Self:
        """copy self"""
        ...
    
    @classmethod
    def create(cls, value: Union[str, XPathSelector]) -> XPathSelector:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __and__(self, value) -> XPathSelector:
        ...
    
    def __or__(self, value) -> XPathSelector:
        ...
    
    @deprecated(reason="use and_ or & instead")
    def xpath(self, _xpath: Union[list, tuple, str]) -> XPathSelector:
        """
        add xpath to condition list
        the element should match all conditions
        """
        ...
    
    def child(self, _xpath: str) -> XPathSelector:
        """
        add child xpath
        """
        ...
    
    def all(self, source: PageSource) -> List[XMLElement]:
        """find all matched elements"""
        ...
    


class DeviceXPathSelector(XPathSelector):
    def __init__(self, xpath: Union[str, AbstractSelector], parent: XPathEntry, source: Optional[PageSource] = ...) -> None:
        ...
    
    def from_parent(self, p: XPathSelector): # -> DeviceXPathSelector:
        ...
    
    def __and__(self, value) -> DeviceXPathSelector:
        ...
    
    def __or__(self, value) -> DeviceXPathSelector:
        ...
    
    def fallback(self, func: Optional[Callable[..., bool]] = ..., *args, **kwargs): # -> Self:
        """
        callback on failure
        """
        ...
    
    def all(self, source: Optional[PageSource] = ...) -> List[DeviceXMLElement]:
        """find all matched elements"""
        ...
    
    @property
    def exists(self) -> bool:
        ...
    
    def get(self, timeout=...): # -> DeviceXMLElement:
        """
        Get first matched element

        Args:
            timeout (float): max seconds to wait

        Returns:
            XMLElement

        Raises:
            XPathElementNotFoundError
        """
        ...
    
    def get_last_match(self) -> DeviceXMLElement:
        ...
    
    def get_text(self) -> Optional[str]:
        """
        get element text

        Returns:
            string of node text

        Raises:
            XPathElementNotFoundError
        """
        ...
    
    def set_text(self, text: str): # -> None:
        ...
    
    def wait(self, timeout=...) -> bool:
        """ wait until element found """
        ...
    
    def match(self) -> Optional[DeviceXMLElement]:
        """
        Returns:
            None or matched DeviceXMLElement
        """
        ...
    
    def wait_gone(self, timeout=...) -> bool:
        """
        Args:
            timeout (float): seconds

        Returns:
            True if gone else False
        """
        ...
    
    def click_nowait(self): # -> None:
        ...
    
    def click(self, timeout=...): # -> object | None:
        """find element and perform click"""
        ...
    
    def click_exists(self, timeout=...) -> bool:
        """return if clicked"""
        ...
    
    def long_click(self): # -> None:
        """find element and perform long click"""
        ...
    
    def screenshot(self) -> Image.Image:
        """take element screenshot"""
        ...
    
    def __getattr__(self, key: str): # -> Any:
        """
        In IPython console, attr:_ipython_canary_method_should_not_exist_ will be called
        So here ignore all attr startswith _
        """
        ...
    


class XMLElement:
    def __init__(self, elem: etree._Element) -> None:
        """
        Args:
            elem: lxml node
            d: uiautomator2 instance
        """
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __eq__(self, value) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def get_xpath(self, strip_index: bool = ...): # -> str:
        """get element full xpath"""
        ...
    
    def center(self): # -> tuple[int, int]:
        """
        Returns:
            (x, y)
        """
        ...
    
    def offset(self, px: float = ..., py: float = ...): # -> tuple[int, int]:
        """
        Offset from left_top

        Args:
            px (float): percent of width
            py (float): percent of height

        Example:
            offset(0.5, 0.5) means center
        """
        ...
    
    def parent(self, xpath: Optional[str] = ...) -> Union[XMLElement, None]:
        """
        Returns parent element
        """
        ...
    
    @functools.cached_property
    def bounds(self) -> Tuple[int, int, int, int]:
        """
        Returns:
            tuple of (left, top, right, bottom)
        """
        ...
    
    @property
    def rect(self) -> Tuple[int, int, int, int]:
        """
        Returns:
            (left_top_x, left_top_y, width, height)
        """
        ...
    
    @property
    def text(self):
        ...
    
    @property
    def attrib(self) -> Dict[str, str]:
        ...
    
    @property
    def info(self) -> Dict[str, Any]:
        ...
    


class DeviceXMLElement(XMLElement):
    def __init__(self, el: XMLElement, parent: XPathEntry) -> None:
        ...
    
    def click(self): # -> None:
        """
        click element, 100ms between down and up
        """
        ...
    
    def long_click(self): # -> None:
        """
        Sometime long click is needed, 400ms between down and up
        """
        ...
    
    def screenshot(self): # -> Image:
        """
        Take screenshot of element
        """
        ...
    
    def swipe(self, direction: Union[Direction, str], scale: float = ...): # -> None:
        """
        Args:
            direction: one of ["left", "right", "up", "down"]
            scale: percent of swipe, range (0, 1.0)

        Raises:
            AssertionError, ValueError
        """
        ...
    
    def scroll(self, direction: Union[Direction, str] = ...) -> bool:
        """
        Args:
            direction: Direction eg: Direction.FORWARD

        Returns:
            bool: if can be scroll again
        """
        ...
    
    def scroll_to(self, xpath: str, direction: Direction = ..., max_swipes: int = ...) -> Union[XMLElement, None]:
        ...
    
    def percent_bounds(self, wsize: Optional[tuple] = ...): # -> tuple[Any | float, Any | float, Any | float, Any | float]:
        """
        Args:
            wsize (tuple(int, int)): window size

        Returns:
            list of 4 float, eg: 0.1, 0.2, 0.5, 0.8
        """
        ...
    
    def percent_size(self): # -> tuple[float, float]:
        """Returns:
        (float, float): eg, (0.5, 0.5) means 50%, 50%
        """
        ...
    


